<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://weenews.github.io</id>
    <title>WeeNews&apos;s blog</title>
    <updated>2020-05-11T11:05:35.815Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://weenews.github.io"/>
    <link rel="self" href="https://weenews.github.io/atom.xml"/>
    <subtitle>æ¸©æ•…è€ŒçŸ¥æ–°</subtitle>
    <logo>https://weenews.github.io/images/avatar.png</logo>
    <icon>https://weenews.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WeeNews&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[linuxå†…æ ¸åè®®æ ˆä¹‹ç½‘ç»œä¿¡æ¯ç»Ÿè®¡SNMP]]></title>
        <id>https://weenews.github.io/post/linux-nei-he-xie-yi-zhan-zhi-wang-luo-xin-xi-tong-ji-snmp/</id>
        <link href="https://weenews.github.io/post/linux-nei-he-xie-yi-zhan-zhi-wang-luo-xin-xi-tong-ji-snmp/">
        </link>
        <updated>2020-05-11T10:53:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#snmp%E7%AE%80%E4%BB%8B">SNMPç®€ä»‹</a></li>
<li><a href="#snmp%E4%BF%A1%E6%81%AF%E7%BB%9F%E8%AE%A1%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90">SNMPä¿¡æ¯ç»Ÿè®¡æ¡†æ¶å’Œå®ç°åˆ†æ</a>
<ul>
<li><a href="#%E6%A1%86%E6%9E%B6">æ¡†æ¶</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">å…·ä½“å®ç°</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="snmpç®€ä»‹">SNMPç®€ä»‹</h1>
<p>SNMPæ˜¯è‹±æ–‡&quot;Simple Network Management Protocol&quot;çš„ç¼©å†™ï¼Œä¸­æ–‡æ„æ€æ˜¯&quot;ç®€å•ç½‘ç»œç®¡ç†åè®®&quot;ã€‚SNMPæ˜¯ä¸€ç§ç®€å•ç½‘ç»œç®¡ç†åè®®ï¼Œå®ƒå±äºTCP/IPäº”å±‚åè®®ä¸­çš„åº”ç”¨å±‚åè®®ï¼Œç”¨äºç½‘ç»œç®¡ç†çš„åè®®ã€‚SNMPä¸»è¦ç”¨äºç½‘ç»œè®¾å¤‡çš„ç®¡ç†ã€‚ç”±äºSNMPåè®®ç®€å•å¯é  ï¼Œå—åˆ°äº†ä¼—å¤šå‚å•†çš„æ¬¢è¿ï¼Œæˆä¸ºäº†ç›®å‰æœ€ä¸ºå¹¿æ³›çš„ç½‘ç®¡åè®®ã€‚<br>
<strong>SNMPçš„å·¥ä½œæ–¹å¼</strong>ï¼šç®¡ç†å‘˜éœ€è¦å‘è®¾å¤‡è·å–æ•°æ®ï¼Œæ‰€ä»¥SNMPæä¾›äº†ã€è¯»ã€‘æ“ä½œï¼›ç®¡ç†å‘˜éœ€è¦å‘è®¾å¤‡æ‰§è¡Œè®¾ç½®æ“ä½œï¼Œæ‰€ä»¥SNMPæä¾›äº†ã€å†™ã€‘æ“ä½œï¼›è®¾å¤‡éœ€è¦åœ¨é‡è¦çŠ¶å†µæ”¹å˜çš„æ—¶å€™ï¼Œå‘ç®¡ç†å‘˜é€šæŠ¥äº‹ä»¶çš„å‘ç”Ÿï¼Œæ‰€ä»¥SNMPæä¾›äº†ã€Trapã€‘æ“ä½œã€‚</p>
<p>åœ¨å…·ä½“å®ç°ä¸Šï¼ŒSNMPä¸ºç®¡ç†å‘˜æä¾›äº†ä¸€ä¸ªç½‘ç®¡å¹³å°(NMS)ï¼Œåˆç§°ä¸ºã€ç®¡ç†ç«™ã€‘ï¼Œè´Ÿè´£ç½‘ç®¡å‘½ä»¤çš„å‘å‡ºã€æ•°æ®å­˜å‚¨ã€åŠæ•°æ®åˆ†æã€‚ã€è¢«ã€‘ç›‘ç®¡çš„è®¾å¤‡ä¸Šè¿è¡Œä¸€ä¸ªSNMPä»£ç†(Agent))ï¼Œä»£ç†å®ç°è®¾å¤‡ä¸ç®¡ç†ç«™çš„SNMPé€šä¿¡ã€‚<br>
<img src="https://img-blog.csdnimg.cn/20200421094847672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbnFpYW5neGlu,size_16,color_FFFFFF,t_70" alt="SNMPçš„å®ç°ç»“æ„" loading="lazy"><br>
ç®¡ç†ç«™ä¸ä»£ç†ç«¯é€šè¿‡MIBè¿›è¡Œæ¥å£ç»Ÿä¸€ï¼ŒMIBå®šä¹‰äº†è®¾å¤‡ä¸­çš„è¢«ç®¡ç†å¯¹è±¡ã€‚ç®¡ç†ç«™å’Œä»£ç†éƒ½å®ç°äº†ç›¸åº”çš„MIBå¯¹è±¡ï¼Œä½¿å¾—åŒæ–¹å¯ä»¥è¯†åˆ«å¯¹æ–¹çš„æ•°æ®ï¼Œå®ç°é€šä¿¡ã€‚ç®¡ç†ç«™å‘ä»£ç†ç”³è¯·MIBä¸­å®šä¹‰çš„æ•°æ®ï¼Œä»£ç†è¯†åˆ«åï¼Œå°†ç®¡ç†è®¾å¤‡æä¾›çš„ç›¸å…³çŠ¶æ€æˆ–å‚æ•°ç­‰æ•°æ®ï¼ˆ<font color=red><strong>è¿™äº›æ•°æ®ç”±å†…æ ¸çš„ç›¸å…³å®ç°æä¾›ï¼Œå­˜å‚¨äº/procç­‰ä½ç½®ï¼Œä¸‹å›¾æ˜¯/proc/net/snmpæ–‡ä»¶ä¸­çš„å†…å®¹ï¼Œè®°å½•äº†ipv4ç›¸å…³çš„ç»Ÿè®¡ä¿¡æ¯</strong></font>ï¼‰è½¬æ¢ä¸ºMIBå®šä¹‰çš„æ ¼å¼ï¼Œåº”ç­”ç»™ç®¡ç†ç«™ï¼Œå®Œæˆä¸€æ¬¡ç®¡ç†æ“ä½œã€‚<br>
<img src="https://img-blog.csdnimg.cn/20200421095714443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbnFpYW5neGlu,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" loading="lazy"><br>
<strong>å†…æ ¸ç½‘ç»œåè®®</strong>å¯¹SNMPåè®®çš„æ”¯æŒä¸»è¦ä½“ç°åœ¨ç»Ÿè®¡äº†ç›¸å…³çš„ç½‘ç»œä¿¡æ¯ï¼Œå¹¶å°†è¿™äº›ä¿¡æ¯é€šè¿‡procç³»ç»Ÿæˆ–å…¶ä»–é…ç½®æ–‡ä»¶è¿›è¡Œå±•ç¤ºï¼ˆæœ¬äººé¡¹ç›®åªæ˜¯ç®€å•æ¶‰åŠåˆ°è¿™ä¸ªåè®®ï¼Œè¿™æ˜¯æˆ‘å¯¹å®ƒçš„ä¸€ä¸ªç®€å•ç†è§£ï¼Œå¦‚æœæœ‰è¯¯æ¬¢è¿æŒ‡æ­£ã€äº¤æµï¼‰ã€‚ä¸‹é¢çš„å†…å®¹å°±æ˜¯ä»‹ç»å†…æ ¸ç½‘ç»œæ ˆæ˜¯å¦‚ä½•æä¾›è¿™äº›ç»Ÿè®¡ä¿¡æ¯çš„ï¼Œå®ƒçš„å®ç°æ¡†æ¶æ˜¯æ€æ ·çš„ã€‚</p>
<h1 id="snmpä¿¡æ¯ç»Ÿè®¡æ¡†æ¶å’Œå®ç°åˆ†æ">SNMPä¿¡æ¯ç»Ÿè®¡æ¡†æ¶å’Œå®ç°åˆ†æ</h1>
<h2 id="æ¡†æ¶">æ¡†æ¶</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200422093723284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbnFpYW5neGlu,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" loading="lazy"></figure>
<h2 id="å…·ä½“å®ç°">å…·ä½“å®ç°</h2>
<p><strong>ç›¸å…³ç»“æ„ä½“å’Œå‡½æ•°çš„ä»£ç å±•ç¤ºåœ¨ä¸‹æ–¹çš„ä»£ç å—ä¸­ï¼Œè¯·è‡ªè¡ŒæŸ¥çœ‹ã€‚</strong><br>
1ã€é¦–å…ˆåœ¨netç»“æ„ä¸­å®šä¹‰äº†ä¸€ä¸ªnetns_mibç±»å‹çš„mibæˆå‘˜ï¼Œè¯¥æˆå‘˜ä¸­é€šè¿‡å®çš„æ–¹å¼å®šä¹‰äº†å­˜æ”¾å„åè®®ç»Ÿè®¡ä¿¡æ¯çš„æˆå‘˜ï¼ˆ<em><strong>æ˜¯æŒ‡é’ˆç±»å‹ï¼Œæ‰€ä»¥éœ€è¦åˆå§‹åŒ–åˆ†é…å†…å­˜</strong></em>ï¼‰ï¼Œå®ƒä»¬çš„ç±»å‹è¢«å®šä¹‰åœ¨&lt;include/net/snmp.h&gt;ä¸­ï¼Œå¤§å¤šæ•°ä¸ºä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„ä¸­å­˜æ”¾å„ä¸ªç»Ÿè®¡ä¿¡æ¯ï¼Œè‡³äºæ•°ç»„ä¸­ä»€ä¹ˆä½ç½®å­˜æ”¾ä»€ä¹ˆä¿¡æ¯åˆ™ç”±å®šä¹‰åœ¨&lt;include/uapi/linux/snmp.h&gt;ä¸­çš„æšä¸¾ç±»å‹å®šä¹‰ï¼Œè¿™äº›æšä¸¾ç±»å‹éƒ½ä»¥0å¼€å§‹ï¼Œè¡¨ç¤ºæ•°ç»„çš„ä¸‹æ ‡(è§ä¸‹æ–¹ä»£ç å—)ã€‚</p>
<pre><code class="language-c">struct net {
	atomic_t		passive;	/* To decided when the network
						 * namespace should be freed.
						 */
	atomic_t		count;		/* To decided when the network
						 *  namespace should be shut down.
						 */
	spinlock_t		rules_mod_lock;

	u32			hash_mix;
	atomic64_t		cookie_gen;

	struct list_head	list;		/* list of network namespaces */
	struct list_head	cleanup_list;	/* namespaces on death row */
	struct list_head	exit_list;	/* Use only net_mutex */

	struct user_namespace   *user_ns;	/* Owning user namespace */
	spinlock_t		nsid_lock;
	struct idr		netns_ids;

	struct ns_common	ns;

	struct proc_dir_entry 	*proc_net;
	struct proc_dir_entry 	*proc_net_stat;

#ifdef CONFIG_SYSCTL
	struct ctl_table_set	sysctls;
#endif

	struct sock 		*rtnl;			/* rtnetlink socket */
	struct sock		*genl_sock;

	struct list_head 	dev_base_head;
	struct hlist_head 	*dev_name_head;
	struct hlist_head	*dev_index_head;
	unsigned int		dev_base_seq;	/* protected by rtnl_mutex */
	int			ifindex;
	unsigned int		dev_unreg_count;

	/* core fib_rules */
	struct list_head	rules_ops;


	struct net_device       *loopback_dev;          /* The loopback */
	struct netns_core	core;
	struct netns_mib	mib;    /* here*/
	struct netns_packet	packet;
	struct netns_unix	unx;
	struct netns_ipv4	ipv4;
#if IS_ENABLED(CONFIG_IPV6)
	struct netns_ipv6	ipv6;
#endif
......åé¢çš„ä»£ç çœç•¥
</code></pre>
<pre><code class="language-c">struct netns_mib {
	DEFINE_SNMP_STAT(struct tcp_mib, tcp_statistics);
	DEFINE_SNMP_STAT(struct ipstats_mib, ip_statistics);
	DEFINE_SNMP_STAT(struct linux_mib, net_statistics);
	DEFINE_SNMP_STAT(struct udp_mib, udp_statistics);
	DEFINE_SNMP_STAT(struct udp_mib, udplite_statistics);
	DEFINE_SNMP_STAT(struct icmp_mib, icmp_statistics);
	DEFINE_SNMP_STAT_ATOMIC(struct icmpmsg_mib, icmpmsg_statistics);

#if IS_ENABLED(CONFIG_IPV6)
	struct proc_dir_entry *proc_net_devsnmp6;
	DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6);
	DEFINE_SNMP_STAT(struct udp_mib, udplite_stats_in6);
	DEFINE_SNMP_STAT(struct ipstats_mib, ipv6_statistics);
	DEFINE_SNMP_STAT(struct icmpv6_mib, icmpv6_statistics);
	DEFINE_SNMP_STAT_ATOMIC(struct icmpv6msg_mib, icmpv6msg_statistics);
#endif
#ifdef CONFIG_XFRM_STATISTICS
	DEFINE_SNMP_STAT(struct linux_xfrm_mib, xfrm_statistics);
#endif
};
</code></pre>
<pre><code class="language-c">struct ipstats_mib {
	/* mibs[] must be first field of struct ipstats_mib */
	u64		mibs[IPSTATS_MIB_MAX];
	struct u64_stats_sync syncp;
};

/* ICMP */
#define ICMP_MIB_MAX	__ICMP_MIB_MAX
struct icmp_mib {
	unsigned long	mibs[ICMP_MIB_MAX];
};
</code></pre>
<pre><code class="language-c">       ......
enum
{
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM,			/* RtoAlgorithm */
	TCP_MIB_RTOMIN,				/* RtoMin */
	TCP_MIB_RTOMAX,				/* RtoMax */
	TCP_MIB_MAXCONN,			/* MaxConn */
	TCP_MIB_ACTIVEOPENS,			/* ActiveOpens */
	TCP_MIB_PASSIVEOPENS,			/* PassiveOpens */
	TCP_MIB_ATTEMPTFAILS,			/* AttemptFails */
	TCP_MIB_ESTABRESETS,			/* EstabResets */
	TCP_MIB_CURRESTAB,			/* CurrEstab */
	TCP_MIB_INSEGS,				/* InSegs */
	TCP_MIB_OUTSEGS,			/* OutSegs */
	TCP_MIB_RETRANSSEGS,			/* RetransSegs */
	TCP_MIB_INERRS,				/* InErrs */
	TCP_MIB_OUTRSTS,			/* OutRsts */
	TCP_MIB_CSUMERRORS,			/* InCsumErrors */
	__TCP_MIB_MAX
};

/* udp mib definitions */
/*
 * RFC 1213:  MIB-II UDP group
 * RFC 2013 (updates 1213):  SNMPv2-MIB-UDP
 */
enum
{
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS,			/* InDatagrams */
	UDP_MIB_NOPORTS,			/* NoPorts */
	UDP_MIB_INERRORS,			/* InErrors */
	UDP_MIB_OUTDATAGRAMS,			/* OutDatagrams */
	UDP_MIB_RCVBUFERRORS,			/* RcvbufErrors */
	UDP_MIB_SNDBUFERRORS,			/* SndbufErrors */
	UDP_MIB_CSUMERRORS,			/* InCsumErrors */
	UDP_MIB_IGNOREDMULTI,			/* IgnoredMulti */
	__UDP_MIB_MAX
};
            ......
</code></pre>
<p>2ã€åè®®æ—åœ¨åˆå§‹åŒ–æ—¶ä¸ºè¿™äº›ç»Ÿè®¡ç»“æ„åˆ†é…ç©ºé—´ï¼Œè¿›è¡Œåˆå§‹åŒ–ï¼Œè¿™é‡Œåˆå§‹åŒ–ç”¨çš„æ˜¯per_cpuå˜é‡ï¼Œå³åœ¨æ¯ä¸ªcpuä¸­éƒ½åˆ†é…ä¸€ä¸ªè¯¥å˜é‡çš„å‰¯æœ¬ï¼Œè¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†å‡å°‘åŒæ­¥æœºåˆ¶å¸¦æ¥çš„æ€§èƒ½æŸè€—ï¼ˆåœ¨å¤šå¤„ç†å™¨ç¯å¢ƒä¸‹é¿å…äº†åœ¨ä¿®æ”¹æ­¤å€¼æ—¶çš„åŠ é”æ“ä½œï¼Œé€šè¿‡ç©ºé—´æ¢æ—¶é—´ï¼‰ã€‚<a href="http://www.wowotech.net/linux_kenrel/per-cpu.html">per_cpuç›¸å…³</a>ã€‚</p>
<pre><code class="language-c">static __net_init int ipv4_mib_init_net(struct net *net)
{
	int i;

	net-&gt;mib.tcp_statistics = alloc_percpu(struct tcp_mib);
	if (!net-&gt;mib.tcp_statistics)
		goto err_tcp_mib;
	net-&gt;mib.ip_statistics = alloc_percpu(struct ipstats_mib);
	if (!net-&gt;mib.ip_statistics)
		goto err_ip_mib;

	for_each_possible_cpu(i) {
		struct ipstats_mib *af_inet_stats;
		af_inet_stats = per_cpu_ptr(net-&gt;mib.ip_statistics, i);
		u64_stats_init(&amp;af_inet_stats-&gt;syncp);
	}

	net-&gt;mib.net_statistics = alloc_percpu(struct linux_mib);
	if (!net-&gt;mib.net_statistics)
		goto err_net_mib;
	net-&gt;mib.udp_statistics = alloc_percpu(struct udp_mib);
	if (!net-&gt;mib.udp_statistics)
		goto err_udp_mib;
	net-&gt;mib.udplite_statistics = alloc_percpu(struct udp_mib);
	if (!net-&gt;mib.udplite_statistics)
		goto err_udplite_mib;
	net-&gt;mib.icmp_statistics = alloc_percpu(struct icmp_mib);
	if (!net-&gt;mib.icmp_statistics)
		goto err_icmp_mib;
	net-&gt;mib.icmpmsg_statistics = kzalloc(sizeof(struct icmpmsg_mib),
					      GFP_KERNEL);
	if (!net-&gt;mib.icmpmsg_statistics)
		goto err_icmpmsg_mib;

	tcp_mib_init(net);
	return 0;

err_icmpmsg_mib:
	free_percpu(net-&gt;mib.icmp_statistics);
err_icmp_mib:
	free_percpu(net-&gt;mib.udplite_statistics);
err_udplite_mib:
	free_percpu(net-&gt;mib.udp_statistics);
err_udp_mib:
	free_percpu(net-&gt;mib.net_statistics);
err_net_mib:
	free_percpu(net-&gt;mib.ip_statistics);
err_ip_mib:
	free_percpu(net-&gt;mib.tcp_statistics);
err_tcp_mib:
	return -ENOMEM;
}

static __net_exit void ipv4_mib_exit_net(struct net *net)
{
	kfree(net-&gt;mib.icmpmsg_statistics);
	free_percpu(net-&gt;mib.icmp_statistics);
	free_percpu(net-&gt;mib.udplite_statistics);
	free_percpu(net-&gt;mib.udp_statistics);
	free_percpu(net-&gt;mib.net_statistics);
	free_percpu(net-&gt;mib.ip_statistics);
	free_percpu(net-&gt;mib.tcp_statistics);
}

static __net_initdata struct pernet_operations ipv4_mib_ops = {
	.init = ipv4_mib_init_net,
	.exit = ipv4_mib_exit_net,
};

static int __init init_ipv4_mibs(void)
{
	return register_pernet_subsys(&amp;ipv4_mib_ops);
}
</code></pre>
<p>3ã€å…§é•¶åœ¨ç½‘ç»œæ ˆä¸­çš„ç»Ÿè®¡å‡½æ•°åœ¨å¯¹åº”çš„ä½ç½®è¿›è¡Œç»Ÿè®¡ï¼Œå°†ä¿¡æ¯å†™å…¥ä¸Šè¿°çš„ç»Ÿè®¡å­—æ®µï¼ˆç»Ÿè®¡åˆ°å½“å‰cpuçš„å‰¯æœ¬ä¸­ï¼‰ã€‚æ¯”å¦‚ä¸‹æ–¹udp_recvmsgå‡½æ•°ä¸­çš„<strong>UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite)</strong> å’Œ<br>
<strong>UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite)</strong> å°±æ˜¯åœ¨ç»Ÿè®¡æ ¡éªŒå’Œé”™è¯¯çš„æ•°æ®åŒ…ä»¥åŠæ¥æ”¶å‡ºé”™çš„æ•°æ®åŒ…<br>
è¿™äº›å®å…¶å®å°±æ˜¯å¢åŠ å¯¹åº”ç»Ÿè®¡å­—æ®µçš„å€¼ã€‚</p>
<pre><code class="language-c">int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
		int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	DECLARE_SOCKADDR(struct sockaddr_in *, sin, msg-&gt;msg_name);
	struct sk_buff *skb;
	unsigned int ulen, copied;
	int peeked, off = 0;
	int err;
	int is_udplite = IS_UDPLITE(sk);
	bool checksum_valid = false;
	bool slow;

	if (flags &amp; MSG_ERRQUEUE)
		return ip_recv_error(sk, msg, len, addr_len);

try_again:
	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
				  &amp;peeked, &amp;off, &amp;err);
	if (!skb)
		goto out;

	ulen = skb-&gt;len - sizeof(struct udphdr);
	copied = len;
	if (copied &gt; ulen)
		copied = ulen;
	else if (copied &lt; ulen)
		msg-&gt;msg_flags |= MSG_TRUNC;

	/*
	 * If checksum is needed at all, try to do it while copying the
	 * data.  If the data is truncated, or if we only want a partial
	 * coverage checksum (UDP-Lite), do it before the copy.
	 */

	if (copied &lt; ulen || UDP_SKB_CB(skb)-&gt;partial_cov) {
		checksum_valid = !udp_lib_checksum_complete(skb);
		if (!checksum_valid)
			goto csum_copy_err;
	}

	if (checksum_valid || skb_csum_unnecessary(skb))
		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
					    msg, copied);
	else {
		err = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr),
						     msg);

		if (err == -EINVAL)
			goto csum_copy_err;
	}

	if (unlikely(err)) {
		trace_kfree_skb(skb, udp_recvmsg);
		if (!peeked) {
			atomic_inc(&amp;sk-&gt;sk_drops);
			UDP_INC_STATS_USER(sock_net(sk),
					   UDP_MIB_INERRORS, is_udplite);
		}
		goto out_free;
	}

	if (!peeked)
		UDP_INC_STATS_USER(sock_net(sk),
				UDP_MIB_INDATAGRAMS, is_udplite);

	sock_recv_ts_and_drops(msg, sk, skb);

	/* Copy the address. */
	if (sin) {
		sin-&gt;sin_family = AF_INET;
		sin-&gt;sin_port = udp_hdr(skb)-&gt;source;
		sin-&gt;sin_addr.s_addr = ip_hdr(skb)-&gt;saddr;
		memset(sin-&gt;sin_zero, 0, sizeof(sin-&gt;sin_zero));
		*addr_len = sizeof(*sin);
	}
	if (inet-&gt;cmsg_flags)
		ip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr), off);

	err = copied;
	if (flags &amp; MSG_TRUNC)
		err = ulen;

out_free:
	skb_free_datagram_locked(sk, skb);
out:
	return err;

csum_copy_err:
	slow = lock_sock_fast(sk);
	if (!skb_kill_datagram(sk, skb, flags)) {
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
	}
	unlock_sock_fast(sk, slow);

	/* starting over for a new packet, but check if we need to yield */
	cond_resched();
	msg-&gt;msg_flags &amp;= ~MSG_TRUNC;
	goto try_again;
}
</code></pre>
<p>4ã€å°†è¿™äº›æ•°æ®é€šè¿‡procç³»ç»Ÿï¼ˆè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼Œå­˜åœ¨äºå†…å­˜ä¸­ï¼‰å‘ç”¨æˆ·æä¾›è®¿é—®ã€‚è¿™æ—¶éœ€è¦å°†å¯¹åº”å­—æ®µåœ¨æ‰€æœ‰cpuä¸­çš„å‰¯æœ¬åŠ èµ·æ¥ï¼Œè¿™ä¸ªå·¥ä½œåœ¨ipv4ä¸­æ˜¯é€šè¿‡ä»¥ä¸‹å‡½æ•°å®Œæˆçš„ã€‚</p>
<pre><code class="language-c">unsigned long snmp_fold_field(void __percpu *mib, int offt)
{
	unsigned long res = 0;
	int i;

	for_each_possible_cpu(i)
		res += snmp_get_cpu_field(mib, i, offt);
	return res;
}
</code></pre>
<p>æ‰€æœ‰ç»Ÿè®¡ä¿¡æ¯éƒ½è¢«é€šè¿‡/proc/net/snmpæ–‡ä»¶å±•ç¤ºç»™ç”¨æˆ·ã€‚<br>
è¿™éƒ¨åˆ†çš„å®ç°åœ¨å¯¹åº”åè®®æ—ä¸‹çš„proc.cæ–‡ä»¶ä¸­ï¼Œå°†ä¸Šè¿°ç»Ÿè®¡ä¿¡æ¯æŒ‰ç…§ç‰¹å®šæ ¼å¼å±•ç¤ºåœ¨procæ–‡ä»¶ä¸­ã€‚</p>
<pre><code class="language-c">static int snmp_seq_show(struct seq_file *seq, void *v)
{
	int i;
	struct net *net = seq-&gt;private;

	seq_puts(seq, &quot;Ip: Forwarding DefaultTTL&quot;);

	for (i = 0; snmp4_ipstats_list[i].name != NULL; i++)
		seq_printf(seq, &quot; %s&quot;, snmp4_ipstats_list[i].name);

	seq_printf(seq, &quot;\nIp: %d %d&quot;,
		   IPV4_DEVCONF_ALL(net, FORWARDING) ? 1 : 2,
		   sysctl_ip_default_ttl);

	BUILD_BUG_ON(offsetof(struct ipstats_mib, mibs) != 0);
	for (i = 0; snmp4_ipstats_list[i].name != NULL; i++)
		seq_printf(seq, &quot; %llu&quot;,
			   snmp_fold_field64(net-&gt;mib.ip_statistics,
					     snmp4_ipstats_list[i].entry,
					     offsetof(struct ipstats_mib, syncp)));

	icmp_put(seq);	/* RFC 2011 compatibility */
	icmpmsg_put(seq);

	seq_puts(seq, &quot;\nTcp:&quot;);
	for (i = 0; snmp4_tcp_list[i].name != NULL; i++)
		seq_printf(seq, &quot; %s&quot;, snmp4_tcp_list[i].name);

	seq_puts(seq, &quot;\nTcp:&quot;);
	for (i = 0; snmp4_tcp_list[i].name != NULL; i++) {
		/* MaxConn field is signed, RFC 2012 */
		if (snmp4_tcp_list[i].entry == TCP_MIB_MAXCONN)
			seq_printf(seq, &quot; %ld&quot;,
				   snmp_fold_field(net-&gt;mib.tcp_statistics,
						   snmp4_tcp_list[i].entry));
		else
			seq_printf(seq, &quot; %lu&quot;,
				   snmp_fold_field(net-&gt;mib.tcp_statistics,
						   snmp4_tcp_list[i].entry));
	}

	seq_puts(seq, &quot;\nUdp:&quot;);
	for (i = 0; snmp4_udp_list[i].name != NULL; i++)
		seq_printf(seq, &quot; %s&quot;, snmp4_udp_list[i].name);

	seq_puts(seq, &quot;\nUdp:&quot;);
	for (i = 0; snmp4_udp_list[i].name != NULL; i++)
		seq_printf(seq, &quot; %lu&quot;,
			   snmp_fold_field(net-&gt;mib.udp_statistics,
					   snmp4_udp_list[i].entry));

	/* the UDP and UDP-Lite MIBs are the same */
	seq_puts(seq, &quot;\nUdpLite:&quot;);
	for (i = 0; snmp4_udp_list[i].name != NULL; i++)
		seq_printf(seq, &quot; %s&quot;, snmp4_udp_list[i].name);

	seq_puts(seq, &quot;\nUdpLite:&quot;);
	for (i = 0; snmp4_udp_list[i].name != NULL; i++)
		seq_printf(seq, &quot; %lu&quot;,
			   snmp_fold_field(net-&gt;mib.udplite_statistics,
					   snmp4_udp_list[i].entry));

	seq_putc(seq, '\n');
	return 0;
}

static __net_init int ip_proc_init_net(struct net *net)
{
	if (!proc_create(&quot;sockstat&quot;, S_IRUGO, net-&gt;proc_net,
			 &amp;sockstat_seq_fops))
		goto out_sockstat;
	if (!proc_create(&quot;netstat&quot;, S_IRUGO, net-&gt;proc_net, &amp;netstat_seq_fops))
		goto out_netstat;
	if (!proc_create(&quot;snmp&quot;, S_IRUGO, net-&gt;proc_net, &amp;snmp_seq_fops))
		goto out_snmp;

	return 0;

out_snmp:
	remove_proc_entry(&quot;netstat&quot;, net-&gt;proc_net);
out_netstat:
	remove_proc_entry(&quot;sockstat&quot;, net-&gt;proc_net);
out_sockstat:
	return -ENOMEM;
}
</code></pre>
<p>æœ¬æ–‡åªæ˜¯ç®€å•å¯¹å†…æ ¸ç½‘ç»œæ ˆå¯¹snmpçš„æ”¯æŒè¿›è¡Œäº†åˆ†æï¼Œæ€»çš„æ¥è¯´ï¼Œè¿™éƒ¨åˆ†å†…å®¹è¿˜æ˜¯æ¯”è¾ƒç‹¬ç«‹çš„ï¼Œåœ¨å¼€å‘è‡ªå·±çš„åè®®æ ˆæ—¶ï¼Œå¦‚æœè¦å¢åŠ è¿™éƒ¨åˆ†å†…å®¹ï¼Œé‚£ä¹ˆä½ æ‰€éœ€è¦åšçš„å¹¶ä¸å¤æ‚ï¼Œå”¯ä¸€æ¯”è¾ƒéº»çƒ¦çš„åœ°æ–¹å¯èƒ½å°±åœ¨äºåœ¨å¢åŠ äº†è‡ªå·±å®šä¹‰çš„å†…å®¹åéœ€è¦é‡æ–°ç¼–è¯‘å†…æ ¸ï¼Œå› ä¸ºä½ æ”¹åŠ¨äº†netç»“æ„ä½“ï¼è¿™ä¸ªç»“æ„ä½“æ˜¯æ‰€æœ‰å†…æ ¸ç½‘ç»œåè®®æ ˆå…±ç”¨çš„ï¼<br>
OVER</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello]]></title>
        <id>https://weenews.github.io/post/hello/</id>
        <link href="https://weenews.github.io/post/hello/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>æ¬¢è¿æ¥åˆ°æˆ‘çš„åšå®¢ï¼</p>
]]></summary>
        <content type="html"><![CDATA[<p>æ¬¢è¿æ¥åˆ°æˆ‘çš„åšå®¢ï¼</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>Windows</strong>ï¼Œ<strong>MacOS</strong> æˆ– <strong>Linux</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>